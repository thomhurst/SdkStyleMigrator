using Microsoft.Build.Evaluation;
using Microsoft.Extensions.Logging;
using SdkMigrator.Abstractions;
using SdkMigrator.Models;
using System.Text.RegularExpressions;
using System.Xml.Linq;

namespace SdkMigrator.Services;

public class TargetScanner : ITargetScanner
{
    private readonly ILogger<TargetScanner> _logger;
    
    // System targets that are typically generated by MSBuild
    private static readonly HashSet<string> SystemTargets = new(StringComparer.OrdinalIgnoreCase)
    {
        // Core MSBuild targets
        "Build", "Rebuild", "Clean", "Compile", "CoreCompile",
        "PrepareForBuild", "GetTargetPath", "GetCopyToOutputDirectoryItems",
        "BeforeBuild", "AfterBuild", "BeforeRebuild", "AfterRebuild",
        "BeforeClean", "AfterClean", "BeforeCompile", "AfterCompile",
        
        // Publishing and packaging
        "Publish", "Package", "BeforePublish", "AfterPublish",
        "GenerateNuspec", "Pack", "PackageFiles",
        
        // Resolution targets
        "ResolveReferences", "ResolveAssemblyReferences", 
        "ResolveProjectReferences", "ResolveNuGetPackageAssets",
        
        // Common generated targets
        "_GenerateCompileDependencyCache", "_CleanGetCurrentAndPriorFileWrites",
        "_CheckForInvalidConfigurationAndPlatform", "_GetProjectReferenceTargetFrameworkProperties"
    };

    // Patterns for categorizing targets
    private static readonly Dictionary<string, string> TargetCategories = new(StringComparer.OrdinalIgnoreCase)
    {
        // NuGet related
        { @".*NuGet.*", "NuGet" },
        { @".*Package.*", "NuGet" },
        { @"EnsureNuGetPackageBuildImports", "NuGet" },
        
        // Build events
        { @"Pre.*Build.*", "Build Events" },
        { @"Post.*Build.*", "Build Events" },
        { @".*BuildEvent.*", "Build Events" },
        
        // Code generation
        { @".*Generate.*", "Code Generation" },
        { @".*CodeGen.*", "Code Generation" },
        { @"T4.*", "Code Generation" },
        
        // Testing
        { @".*Test.*", "Testing" },
        { @".*Coverage.*", "Testing" },
        
        // Deployment
        { @".*Deploy.*", "Deployment" },
        { @".*Publish.*", "Publishing" },
        { @".*ClickOnce.*", "ClickOnce" },
        
        // Versioning
        { @".*Version.*", "Versioning" },
        { @".*AssemblyInfo.*", "Versioning" },
        
        // Custom build steps
        { @".*Copy.*", "File Operations" },
        { @".*Clean.*", "Cleaning" },
        { @".*Transform.*", "Transformation" }
    };

    public TargetScanner(ILogger<TargetScanner> logger)
    {
        _logger = logger;
    }

    public async Task<TargetScanResult> ScanProjectFileTargetsAsync(
        IEnumerable<string> projectFilePaths,
        CancellationToken cancellationToken = default)
    {
        var result = new TargetScanResult();
        var targetsByCategory = new Dictionary<string, List<ProjectTargetInfo>>(StringComparer.OrdinalIgnoreCase);
        
        foreach (var projectPath in projectFilePaths)
        {
            cancellationToken.ThrowIfCancellationRequested();
            
            if (!File.Exists(projectPath))
            {
                _logger.LogWarning("Project file not found: {ProjectPath}", projectPath);
                continue;
            }
            
            _logger.LogInformation("Scanning targets in project file: {ProjectFile}", projectPath);
            
            try
            {
                // Read and parse the project XML directly
                var projectXml = XDocument.Load(projectPath);
                var ns = projectXml.Root?.Name.Namespace ?? XNamespace.None;
                
                // Find all Target elements
                var targets = projectXml.Descendants(ns + "Target");
                
                foreach (var target in targets)
                {
                    var targetName = target.Attribute("Name")?.Value;
                    if (string.IsNullOrEmpty(targetName))
                        continue;
                    
                    // Extract task names from the target
                    var taskNames = new List<string>();
                    foreach (var element in target.Elements())
                    {
                        // Task names are the element names (e.g., Message, Copy, Exec, etc.)
                        var taskName = element.Name.LocalName;
                        if (!string.IsNullOrEmpty(taskName))
                        {
                            taskNames.Add(taskName);
                        }
                    }
                    
                    var targetInfo = new ProjectTargetInfo
                    {
                        ProjectPath = projectPath,
                        TargetName = targetName,
                        Condition = target.Attribute("Condition")?.Value,
                        DependsOnTargets = target.Attribute("DependsOnTargets")?.Value,
                        BeforeTargets = target.Attribute("BeforeTargets")?.Value,
                        AfterTargets = target.Attribute("AfterTargets")?.Value,
                        Label = target.Attribute("Label")?.Value,
                        IsSystemTarget = IsSystemTarget(targetName),
                        Category = CategorizeTarget(targetName, taskNames),
                        Tasks = taskNames
                    };
                    
                    // Group by category
                    var category = targetInfo.Category;
                    if (!targetsByCategory.ContainsKey(category))
                    {
                        targetsByCategory[category] = new List<ProjectTargetInfo>();
                    }
                    targetsByCategory[category].Add(targetInfo);
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error scanning targets in project: {ProjectPath}", projectPath);
            }
        }
        
        // Convert to TargetGroups
        foreach (var kvp in targetsByCategory.OrderBy(k => k.Key))
        {
            var group = new TargetGroup
            {
                GroupName = kvp.Key,
                Category = kvp.Key,
                Targets = kvp.Value
            };
            
            result.TargetGroups.Add(group);
        }
        
        _logger.LogInformation("Target scan complete. Found {TargetCount} targets in {GroupCount} groups", 
            result.TotalTargets, result.TargetGroups.Count);
        
        return await Task.FromResult(result);
    }

    public string CategorizeTarget(string targetName, List<string> taskNames)
    {
        if (string.IsNullOrEmpty(targetName))
            return "Unknown";
            
        // Check against known patterns
        foreach (var pattern in TargetCategories)
        {
            if (Regex.IsMatch(targetName, pattern.Key, RegexOptions.IgnoreCase))
            {
                return pattern.Value;
            }
        }
        
        // Check task names for hints
        if (taskNames.Any(t => t.Contains("Test", StringComparison.OrdinalIgnoreCase)))
            return "Testing";
        if (taskNames.Any(t => t.Contains("Copy", StringComparison.OrdinalIgnoreCase)))
            return "File Operations";
        if (taskNames.Any(t => t.Contains("Exec", StringComparison.OrdinalIgnoreCase)))
            return "Build Commands";
        if (taskNames.Any(t => t.Contains("Transform", StringComparison.OrdinalIgnoreCase)))
            return "Transformation";
        
        return "Custom";
    }

    public bool IsSystemTarget(string targetName)
    {
        if (string.IsNullOrEmpty(targetName))
            return false;
            
        // Check if it's in the known system targets list
        if (SystemTargets.Contains(targetName))
            return true;
            
        // Check for common system target patterns
        if (targetName.StartsWith("_", StringComparison.Ordinal)) // Internal MSBuild targets
            return true;
            
        if (targetName.Contains("MSBuild", StringComparison.OrdinalIgnoreCase))
            return true;
            
        return false;
    }
}