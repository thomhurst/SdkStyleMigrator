using System.Xml.Linq;
using Microsoft.Extensions.Logging;
using SdkMigrator.Abstractions;
using SdkMigrator.Models;

namespace SdkMigrator.Services;

public class CentralPackageManagementGenerator : ICentralPackageManagementGenerator
{
    private readonly ILogger<CentralPackageManagementGenerator> _logger;
    private readonly IAuditService _auditService;
    private readonly MigrationOptions _options;

    public CentralPackageManagementGenerator(
        ILogger<CentralPackageManagementGenerator> logger,
        IAuditService auditService,
        MigrationOptions options)
    {
        _logger = logger;
        _auditService = auditService;
        _options = options;
    }

    public async Task<CentralPackageManagementResult> GenerateDirectoryPackagesPropsAsync(
        string solutionDirectory,
        IEnumerable<MigrationResult> migrationResults,
        CancellationToken cancellationToken = default)
    {
        var result = new CentralPackageManagementResult();
        
        try
        {
            _logger.LogInformation("Analyzing packages for Central Package Management...");
            
            // Collect all package references from migration results
            var allPackages = migrationResults
                .Where(r => r.Success)
                .SelectMany(r => r.MigratedPackages)
                .Where(p => !p.IsTransitive)
                .GroupBy(p => p.PackageId, StringComparer.OrdinalIgnoreCase)
                .ToList();
                
            if (!allPackages.Any())
            {
                _logger.LogInformation("No packages found to centralize");
                result.Success = true;
                return result;
            }
            
            result.PackageCount = allPackages.Count;
            
            // Check for version conflicts
            foreach (var packageGroup in allPackages)
            {
                var versions = packageGroup.Select(p => p.Version).Distinct().ToList();
                if (versions.Count > 1)
                {
                    var conflict = new PackageVersionConflict
                    {
                        PackageId = packageGroup.Key,
                        Versions = versions,
                        ResolvedVersion = ResolveVersionConflict(versions),
                        ResolutionReason = "Selected highest version"
                    };
                    result.VersionConflicts.Add(conflict);
                    
                    _logger.LogWarning("Version conflict for package {PackageId}: {Versions}. Resolved to {ResolvedVersion}",
                        packageGroup.Key, string.Join(", ", versions), conflict.ResolvedVersion);
                }
            }
            
            // Generate Directory.Packages.props
            var directoryPackagesProps = new XDocument(
                new XComment("Central Package Management - Generated by SdkMigrator"),
                new XElement("Project",
                    new XElement("PropertyGroup",
                        new XElement("ManagePackageVersionsCentrally", "true"),
                        new XElement("CentralPackageTransitivePinningEnabled", "true")),
                    new XElement("ItemGroup",
                        allPackages.Select(packageGroup =>
                        {
                            var versions = packageGroup.Select(p => p.Version).Distinct().ToList();
                            var version = versions.Count == 1 ? versions[0] : 
                                result.VersionConflicts.First(c => c.PackageId == packageGroup.Key).ResolvedVersion;
                                
                            return new XElement("PackageVersion",
                                new XAttribute("Include", packageGroup.Key),
                                new XAttribute("Version", version));
                        }))));
                        
            // Add GlobalPackageReferences if any analyzers were found
            var analyzerPackages = allPackages
                .Where(g => IsAnalyzerPackage(g.Key))
                .ToList();
                
            if (analyzerPackages.Any())
            {
                directoryPackagesProps.Root?.Add(
                    new XComment("Global analyzer packages applied to all projects"),
                    new XElement("ItemGroup",
                        analyzerPackages.Select(packageGroup =>
                        {
                            var versions = packageGroup.Select(p => p.Version).Distinct().ToList();
                            var version = versions.Count == 1 ? versions[0] : 
                                result.VersionConflicts.First(c => c.PackageId == packageGroup.Key).ResolvedVersion;
                                
                            return new XElement("GlobalPackageReference",
                                new XAttribute("Include", packageGroup.Key),
                                new XAttribute("Version", version));
                        })));
            }
            
            var outputPath = Path.Combine(solutionDirectory, "Directory.Packages.props");
            
            if (!_options.DryRun)
            {
                // Check if file already exists
                if (File.Exists(outputPath))
                {
                    _logger.LogWarning("Directory.Packages.props already exists at {Path}. Creating backup.", outputPath);
                    File.Copy(outputPath, $"{outputPath}.backup", overwrite: true);
                }
                
                directoryPackagesProps.Save(outputPath);
                _logger.LogInformation("Created Directory.Packages.props at {Path}", outputPath);
                
                // Audit the creation
                await _auditService.LogFileCreationAsync(new FileCreationAudit
                {
                    FilePath = outputPath,
                    FileSize = new FileInfo(outputPath).Length,
                    CreationType = "Central Package Management configuration",
                    FileHash = await FileHashCalculator.CalculateHashAsync(outputPath, cancellationToken)
                }, cancellationToken);
            }
            else
            {
                _logger.LogInformation("[DRY RUN] Would create Directory.Packages.props at {Path}", outputPath);
                _logger.LogDebug("[DRY RUN] Content:\n{Content}", directoryPackagesProps.ToString());
            }
            
            result.DirectoryPackagesPropsPath = outputPath;
            result.Success = true;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to generate Directory.Packages.props");
            result.Errors.Add(ex.Message);
            result.Success = false;
        }
        
        return result;
    }
    
    public async Task<bool> RemoveVersionsFromProjectsAsync(
        IEnumerable<string> projectFiles,
        CancellationToken cancellationToken = default)
    {
        var success = true;
        var updatedCount = 0;
        
        foreach (var projectFile in projectFiles)
        {
            try
            {
                if (!File.Exists(projectFile))
                {
                    _logger.LogWarning("Project file not found: {ProjectFile}", projectFile);
                    continue;
                }
                
                var doc = XDocument.Load(projectFile);
                var modified = false;
                
                // Find all PackageReference elements with Version attribute
                var packageReferences = doc.Descendants("PackageReference")
                    .Where(pr => pr.Attribute("Version") != null)
                    .ToList();
                    
                foreach (var packageRef in packageReferences)
                {
                    // Skip if it has VersionOverride (intentional override)
                    if (packageRef.Attribute("VersionOverride") != null)
                        continue;
                        
                    packageRef.Attribute("Version")?.Remove();
                    modified = true;
                    
                    _logger.LogDebug("Removed Version from PackageReference {Package} in {Project}",
                        packageRef.Attribute("Include")?.Value, projectFile);
                }
                
                if (modified)
                {
                    if (!_options.DryRun)
                    {
                        doc.Save(projectFile);
                        updatedCount++;
                        _logger.LogInformation("Updated {ProjectFile} to use Central Package Management", projectFile);
                    }
                    else
                    {
                        _logger.LogInformation("[DRY RUN] Would update {ProjectFile} to use Central Package Management", projectFile);
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to update project file: {ProjectFile}", projectFile);
                success = false;
            }
        }
        
        _logger.LogInformation("Updated {Count} project files for Central Package Management", updatedCount);
        return success;
    }
    
    private string ResolveVersionConflict(List<string> versions)
    {
        // Simple strategy: pick the highest version
        // In real scenarios, might want more sophisticated resolution
        return versions
            .OrderByDescending(v => v, new VersionComparer())
            .First();
    }
    
    private bool IsAnalyzerPackage(string packageId)
    {
        var analyzerPackages = new[]
        {
            "StyleCop.Analyzers",
            "SonarAnalyzer.CSharp",
            "Microsoft.CodeAnalysis.NetAnalyzers",
            "Microsoft.CodeAnalysis.FxCopAnalyzers",
            "Roslynator.Analyzers"
        };
        
        return analyzerPackages.Any(ap => packageId.StartsWith(ap, StringComparison.OrdinalIgnoreCase)) ||
               packageId.EndsWith(".Analyzers", StringComparison.OrdinalIgnoreCase);
    }
    
    private class VersionComparer : IComparer<string>
    {
        public int Compare(string? x, string? y)
        {
            if (x == null && y == null) return 0;
            if (x == null) return -1;
            if (y == null) return 1;
            
            // Try to parse as semantic versions
            if (Version.TryParse(x, out var vx) && Version.TryParse(y, out var vy))
            {
                return vx.CompareTo(vy);
            }
            
            // Fallback to string comparison
            return string.Compare(x, y, StringComparison.OrdinalIgnoreCase);
        }
    }
    
    public async Task<CleanCpmResult> CleanUnusedPackagesAsync(
        string directoryPath,
        bool dryRun,
        CancellationToken cancellationToken = default)
    {
        var result = new CleanCpmResult { Success = true };
        
        try
        {
            // Find Directory.Packages.props
            var packagesPropsPath = Path.Combine(directoryPath, "Directory.Packages.props");
            if (!File.Exists(packagesPropsPath))
            {
                // Try parent directories up to 3 levels
                var searchDir = directoryPath;
                for (int i = 0; i < 3; i++)
                {
                    var parent = Directory.GetParent(searchDir);
                    if (parent == null) break;
                    
                    searchDir = parent.FullName;
                    packagesPropsPath = Path.Combine(searchDir, "Directory.Packages.props");
                    if (File.Exists(packagesPropsPath))
                    {
                        _logger.LogInformation("Found Directory.Packages.props at: {Path}", packagesPropsPath);
                        break;
                    }
                }
                
                if (!File.Exists(packagesPropsPath))
                {
                    result.Success = false;
                    result.Error = "Directory.Packages.props not found";
                    return result;
                }
            }
            
            // Load Directory.Packages.props
            var packagesDoc = XDocument.Load(packagesPropsPath);
            var packageVersionElements = packagesDoc.Descendants("PackageVersion").ToList();
            
            if (!packageVersionElements.Any())
            {
                _logger.LogInformation("No PackageVersion elements found in Directory.Packages.props");
                return result;
            }
            
            // Find all project files in the directory and subdirectories
            var projectFiles = Directory.GetFiles(directoryPath, "*.csproj", SearchOption.AllDirectories)
                .Concat(Directory.GetFiles(directoryPath, "*.vbproj", SearchOption.AllDirectories))
                .Concat(Directory.GetFiles(directoryPath, "*.fsproj", SearchOption.AllDirectories))
                .Where(f => !f.Contains(".obj", StringComparison.OrdinalIgnoreCase) && 
                           !f.Contains("\\obj\\", StringComparison.OrdinalIgnoreCase) &&
                           !f.Contains("/obj/", StringComparison.OrdinalIgnoreCase))
                .ToList();
            
            _logger.LogInformation("Found {Count} project files to analyze", projectFiles.Count);
            
            // Collect all referenced packages from all projects
            var referencedPackages = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
            
            foreach (var projectFile in projectFiles)
            {
                try
                {
                    var projectDoc = XDocument.Load(projectFile);
                    var packageRefs = projectDoc.Descendants("PackageReference")
                        .Select(pr => pr.Attribute("Include")?.Value)
                        .Where(id => !string.IsNullOrEmpty(id));
                    
                    foreach (var packageId in packageRefs)
                    {
                        referencedPackages.Add(packageId!);
                    }
                }
                catch (Exception ex)
                {
                    _logger.LogWarning(ex, "Failed to read project file: {ProjectFile}", projectFile);
                }
            }
            
            _logger.LogInformation("Found {Count} unique package references across all projects", referencedPackages.Count);
            
            // Find unused packages
            var unusedPackageElements = new List<XElement>();
            foreach (var packageElement in packageVersionElements)
            {
                var packageId = packageElement.Attribute("Include")?.Value;
                if (!string.IsNullOrEmpty(packageId) && !referencedPackages.Contains(packageId))
                {
                    unusedPackageElements.Add(packageElement);
                    result.RemovedPackages.Add(packageId);
                    _logger.LogInformation("Found unused package: {PackageId}", packageId);
                }
            }
            
            if (unusedPackageElements.Any() && !dryRun)
            {
                // Create backup
                if (_options.CreateBackup)
                {
                    var backupPath = packagesPropsPath + ".backup";
                    File.Copy(packagesPropsPath, backupPath, overwrite: true);
                    _logger.LogInformation("Created backup: {BackupPath}", backupPath);
                }
                
                // Remove unused packages
                foreach (var element in unusedPackageElements)
                {
                    element.Remove();
                }
                
                // Clean up empty ItemGroups
                var emptyItemGroups = packagesDoc.Descendants("ItemGroup")
                    .Where(ig => !ig.HasElements && !ig.HasAttributes)
                    .ToList();
                foreach (var ig in emptyItemGroups)
                {
                    ig.Remove();
                }
                
                // Save the cleaned file
                packagesDoc.Save(packagesPropsPath);
                _logger.LogInformation("Updated Directory.Packages.props - removed {Count} unused packages", unusedPackageElements.Count);
            }
            
            return result;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error cleaning Directory.Packages.props");
            result.Success = false;
            result.Error = ex.Message;
            return result;
        }
    }
}