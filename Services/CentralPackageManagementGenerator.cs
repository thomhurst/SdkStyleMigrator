using System.Xml.Linq;
using Microsoft.Extensions.Logging;
using SdkMigrator.Abstractions;
using SdkMigrator.Models;

namespace SdkMigrator.Services;

public class CentralPackageManagementGenerator : ICentralPackageManagementGenerator
{
    private readonly ILogger<CentralPackageManagementGenerator> _logger;
    private readonly IAuditService _auditService;
    private readonly MigrationOptions _options;

    public CentralPackageManagementGenerator(
        ILogger<CentralPackageManagementGenerator> logger,
        IAuditService auditService,
        MigrationOptions options)
    {
        _logger = logger;
        _auditService = auditService;
        _options = options;
    }

    public async Task<CentralPackageManagementResult> GenerateDirectoryPackagesPropsAsync(
        string solutionDirectory,
        IEnumerable<MigrationResult> migrationResults,
        CancellationToken cancellationToken = default)
    {
        var result = new CentralPackageManagementResult();
        
        try
        {
            _logger.LogInformation("Analyzing packages for Central Package Management...");
            
            // Collect all package references from migration results
            var allPackages = migrationResults
                .Where(r => r.Success)
                .SelectMany(r => r.MigratedPackages)
                .Where(p => !p.IsTransitive)
                .GroupBy(p => p.PackageId, StringComparer.OrdinalIgnoreCase)
                .ToList();
                
            if (!allPackages.Any())
            {
                _logger.LogInformation("No packages found to centralize");
                result.Success = true;
                return result;
            }
            
            result.PackageCount = allPackages.Count;
            
            // Check for version conflicts
            foreach (var packageGroup in allPackages)
            {
                var versions = packageGroup.Select(p => p.Version).Distinct().ToList();
                if (versions.Count > 1)
                {
                    var conflict = new PackageVersionConflict
                    {
                        PackageId = packageGroup.Key,
                        Versions = versions,
                        ResolvedVersion = ResolveVersionConflict(versions),
                        ResolutionReason = "Selected highest version"
                    };
                    result.VersionConflicts.Add(conflict);
                    
                    _logger.LogWarning("Version conflict for package {PackageId}: {Versions}. Resolved to {ResolvedVersion}",
                        packageGroup.Key, string.Join(", ", versions), conflict.ResolvedVersion);
                }
            }
            
            // Generate Directory.Packages.props
            var directoryPackagesProps = new XDocument(
                new XComment("Central Package Management - Generated by SdkMigrator"),
                new XElement("Project",
                    new XElement("PropertyGroup",
                        new XElement("ManagePackageVersionsCentrally", "true"),
                        new XElement("CentralPackageTransitivePinningEnabled", "true")),
                    new XElement("ItemGroup",
                        allPackages.Select(packageGroup =>
                        {
                            var versions = packageGroup.Select(p => p.Version).Distinct().ToList();
                            var version = versions.Count == 1 ? versions[0] : 
                                result.VersionConflicts.First(c => c.PackageId == packageGroup.Key).ResolvedVersion;
                                
                            return new XElement("PackageVersion",
                                new XAttribute("Include", packageGroup.Key),
                                new XAttribute("Version", version));
                        }))));
                        
            // Add GlobalPackageReferences if any analyzers were found
            var analyzerPackages = allPackages
                .Where(g => IsAnalyzerPackage(g.Key))
                .ToList();
                
            if (analyzerPackages.Any())
            {
                directoryPackagesProps.Root?.Add(
                    new XComment("Global analyzer packages applied to all projects"),
                    new XElement("ItemGroup",
                        analyzerPackages.Select(packageGroup =>
                        {
                            var versions = packageGroup.Select(p => p.Version).Distinct().ToList();
                            var version = versions.Count == 1 ? versions[0] : 
                                result.VersionConflicts.First(c => c.PackageId == packageGroup.Key).ResolvedVersion;
                                
                            return new XElement("GlobalPackageReference",
                                new XAttribute("Include", packageGroup.Key),
                                new XAttribute("Version", version));
                        })));
            }
            
            var outputPath = Path.Combine(solutionDirectory, "Directory.Packages.props");
            
            if (!_options.DryRun)
            {
                // Check if file already exists
                if (File.Exists(outputPath))
                {
                    _logger.LogWarning("Directory.Packages.props already exists at {Path}. Creating backup.", outputPath);
                    File.Copy(outputPath, $"{outputPath}.backup", overwrite: true);
                }
                
                directoryPackagesProps.Save(outputPath);
                _logger.LogInformation("Created Directory.Packages.props at {Path}", outputPath);
                
                // Audit the creation
                await _auditService.LogFileCreationAsync(new FileCreationAudit
                {
                    FilePath = outputPath,
                    FileSize = new FileInfo(outputPath).Length,
                    CreationType = "Central Package Management configuration",
                    FileHash = await FileHashCalculator.CalculateHashAsync(outputPath, cancellationToken)
                }, cancellationToken);
            }
            else
            {
                _logger.LogInformation("[DRY RUN] Would create Directory.Packages.props at {Path}", outputPath);
                _logger.LogDebug("[DRY RUN] Content:\n{Content}", directoryPackagesProps.ToString());
            }
            
            result.DirectoryPackagesPropsPath = outputPath;
            result.Success = true;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to generate Directory.Packages.props");
            result.Errors.Add(ex.Message);
            result.Success = false;
        }
        
        return result;
    }
    
    public async Task<bool> RemoveVersionsFromProjectsAsync(
        IEnumerable<string> projectFiles,
        CancellationToken cancellationToken = default)
    {
        var success = true;
        var updatedCount = 0;
        
        foreach (var projectFile in projectFiles)
        {
            try
            {
                if (!File.Exists(projectFile))
                {
                    _logger.LogWarning("Project file not found: {ProjectFile}", projectFile);
                    continue;
                }
                
                var doc = XDocument.Load(projectFile);
                var modified = false;
                
                // Find all PackageReference elements with Version attribute
                var packageReferences = doc.Descendants("PackageReference")
                    .Where(pr => pr.Attribute("Version") != null)
                    .ToList();
                    
                foreach (var packageRef in packageReferences)
                {
                    // Skip if it has VersionOverride (intentional override)
                    if (packageRef.Attribute("VersionOverride") != null)
                        continue;
                        
                    packageRef.Attribute("Version")?.Remove();
                    modified = true;
                    
                    _logger.LogDebug("Removed Version from PackageReference {Package} in {Project}",
                        packageRef.Attribute("Include")?.Value, projectFile);
                }
                
                if (modified)
                {
                    if (!_options.DryRun)
                    {
                        doc.Save(projectFile);
                        updatedCount++;
                        _logger.LogInformation("Updated {ProjectFile} to use Central Package Management", projectFile);
                    }
                    else
                    {
                        _logger.LogInformation("[DRY RUN] Would update {ProjectFile} to use Central Package Management", projectFile);
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to update project file: {ProjectFile}", projectFile);
                success = false;
            }
        }
        
        _logger.LogInformation("Updated {Count} project files for Central Package Management", updatedCount);
        return success;
    }
    
    private string ResolveVersionConflict(List<string> versions)
    {
        // Simple strategy: pick the highest version
        // In real scenarios, might want more sophisticated resolution
        return versions
            .OrderByDescending(v => v, new VersionComparer())
            .First();
    }
    
    private bool IsAnalyzerPackage(string packageId)
    {
        var analyzerPackages = new[]
        {
            "StyleCop.Analyzers",
            "SonarAnalyzer.CSharp",
            "Microsoft.CodeAnalysis.NetAnalyzers",
            "Microsoft.CodeAnalysis.FxCopAnalyzers",
            "Roslynator.Analyzers"
        };
        
        return analyzerPackages.Any(ap => packageId.StartsWith(ap, StringComparison.OrdinalIgnoreCase)) ||
               packageId.EndsWith(".Analyzers", StringComparison.OrdinalIgnoreCase);
    }
    
    private class VersionComparer : IComparer<string>
    {
        public int Compare(string? x, string? y)
        {
            if (x == null && y == null) return 0;
            if (x == null) return -1;
            if (y == null) return 1;
            
            // Try to parse as semantic versions
            if (Version.TryParse(x, out var vx) && Version.TryParse(y, out var vy))
            {
                return vx.CompareTo(vy);
            }
            
            // Fallback to string comparison
            return string.Compare(x, y, StringComparison.OrdinalIgnoreCase);
        }
    }
}